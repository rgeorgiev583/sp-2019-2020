# Работа с файлове
(записки към второто упражнение)

Употреба на системните извиквания `open(2)` , `create(2)` , `read(2)` , `write(2)` и `close(2)` .

## `open(2)` 

    #include <fcntl.h>

    int open(const char* pathname, int flags);
    int open(const char* pathname, int flags, mode_t mode);

Системното извикване `open()` отваря файла, определен от подадения като аргумент `път` .Ако този файл не съществува, той ще бъде създаден от `open()` , ако флагът `O_CREAT` бъде зададен в аргумента `флагове` на `open()` .

При успешно отваряне на файла `open()` връща файлов дескриптор, сочещ към отворения файл.Файловият дескриптор представлява малко неотрицателно число, което се използва в последващи извиквания на другите системни извиквания за работа с файлове (т.е. `read(2)` , `write(2)` , `close(2)` и т.н.), за да определи върху кой отворен файл да се извърши съответната операция.Дескрипторът, върнат при успешно извикване на `open()` , е винаги най-малкото такова число, което все още не е асоциирано с отворен файл за текущия процес.

По подразбиране файловият дескриптор остава отворен при извикване на `exec(3)` (т.е.флагът `FD_CLOEXEC` по подразбиране е изключен); флагът `O_CLOEXEC` (описан по-долу) може да се използва с цел затваряне на дескриптора при `exec(3)` .Позицията за четене или писане първоначално е зададена да е в началото на файла (виж `lseek(2)` ).

При извикване на `open()` се създава *дескрипция (инстанция)* на отворен файл, която се добавя в системния списък с отворени файлове.В тази дескрипция се намира текущата позиция за четене или писане във файла, както и флаговете, зададени в аргумента `flags` .Файловият дескриптор играе ролята на указател към дескрипцията.

Аргументът `flags` **трябва** да включва един от следните флагове за *режим на достъп*: `O_RDONLY` (достъп до файла само за четене), `O_WRONLY` (достъп до файла само за писане) или `O_RDWR` (достъп до файла както за четене, така и за писане).

Освен това във `flags` може да се зададат някои допълнителни флагове, комбинирани чрез оператора `|` (побитова дизюнкция) с флага за режим на достъп:

* флагове, свързани с отварянето на файла: `O_CLOEXEC` , `O_CREAT` , `O_EXCL` и `O_TRUNC` ; 
* флагове, свързани със състоянието на отворения файл: `O_APPEND` .

Допълнителните флагове имат следната семантика:

* `O_APPEND` : ако файлът е отворен в режим за писане, всяка операция за писане да се извършва в края на файла.Това означава, че позицията за четене и писане директно се премества в края на файла (все едно е изпълнено `lseek(2)` с втори аргумент `0` и трети аргумент `SEEK_END` ) преди всеки `write(2)` .Разликата с `open(2)` без `O_APPEND` е, че промяната на позицията за писане и самото писане се извършват като единична атомарна операция.

* `O_CLOEXEC` : файловият дескриптор, асоцииран с отворения файл, да се затвори при извикване на `exec(3)` .

* `O_CREAT` : ако файл с път `pathname` към него не съществува, той да бъде създаден с разрешения (т.е.*режим* на файла), зададени посредством аргумента `mode` .Наличието на `O_CREAT` означава, че аргументът `mode` е задължителен.

    За да се зададе режимът на файла, може да се използват следните символни константи:

    - `S_IRWXU` == `00700` : потребителят (собственикът на файла) има разрешения за четене, писане и изпълнение на файла;
    - `S_IRUSR` == `00400` : потребителят има разрешение за четене от файла;
    - `S_IWUSR` == `00200` : потребителят има разрешение за писане във файла;
    - `S_IXUSR` == `00100` : потребителят има разрешение за изпълнение на файла;
    - `S_IRWXG` == `00070` : потребителите от групата, към която принадлежи потребителят, имат разрешения за четене, писане и изпълнение на файла;
    - `S_IRGRP` == `00040` : групата има разрешение за четене от файла;
    - `S_IWGRP` == `00020` : групата има разрешение за писане във файла;
    - `S_IXGRP` == `00010` : групата има разрешение за изпълнение на файла;
    - `S_IRWXO` == `00007` : всички останали потребители имат разрешения за четене, писане и изпълнение на файла;
    - `S_IROTH` == `00004` : всички останали имат разрешение за четене от файла;
    - `S_IWOTH` == `00002` : всички останали имат разрешение за писане във файла;
    - `S_IXOTH` == `00001` : всички останали имат разрешение за изпълнение на файла;
    - `S_ISUID` == `0004000` : *set-user-ID* ( `setuid` ) бит;
    - `S_ISGID` == `0002000` : *set-group-ID* бит;
    - `S_ISVTX` == `0001000` : *sticky* бит.

* `O_EXCL` : ако файл с път `pathname` към него вече съществува, `open()` да върне грешка.Този флаг винаги се използва заедно с `O_CREAT` .

* `O_TRUNC` : ако файлът с път `pathname` към него вече съществува и файлът е отворен в режим на писане, цялото му съдържание да бъде изтрито (т.е.размерът му да се сведе до `0` ).

При грешка `open()` връща стойност `-1` и номерът на грешката се задава в `errno` .

## `creat(2)` 

    int creat(const char *pathname, mode_t mode);

Извикването на `creat()` е еквивалентно на извикване на `open()` със стойност `O_CREAT|O_WRONLY|O_TRUNC` на аргумента `flags` .

## `read(2)` 

    #include <unistd.h>

    ssize_t read(int fd, void* buffer, size_t count); 

Системното извикване `read()` се опитва да прочете `count` на брой байта от файла, указан чрез файловия дескриптор `fd` , в буфера `buffer` .Операцията започва от текущата позиция за четене и писане във файла, като тя се увеличава с броя на успешно прочетените байтове.Ако позицията сочи към края на файла или след него (виж `lseek(2)` ), не се прочита нищо и `read()` връща `0` .

При успех се връща броят на прочетените байтове (ако са `0` , значи сме достигнали края на файла).Не е грешка, ако този брой е по-малък от указания в аргумента `count` : това може да се случи например ако размерът на файла е по-малък от `count` или ако във файла има по-малко от `count` на брой оставащи байтове спрямо текущата позиция за четене и писане.При грешка `read()` връща стойност `-1` и номерът на грешката се задава в `errno` .

## `write(2)` 

    #include <unistd.h>

    ssize_t write(int fd, const void* buffer, size_t count); 

Системното извикване `write()` се опитва да запише `count` на брой байта от буфера `buffer` във файла, указан чрез файловия дескриптор `fd` .Операцията започва от текущата позиция за четене и писане във файла, като тя се увеличава с броя на успешно записаните байтове.

При успех се връща броят на записаните байтове.Не е грешка, ако този брой е `0` или е по-малък от указания в аргумента `count` : това може да се случи например ако няма достатъчно място на устройството, върху което пишем.При грешка `write()` връща стойност `-1` и номерът на грешката се задава в `errno` .

## `close(2)` 

    #include <unistd.h>

    int close(int fd);

Системното извикване `close()` затваря файловия дескриптор `fd` и премахва асоциацията със съотетстващата му дескрипция, така че той да може да бъде преизползван при последващо извикване на `open(2)` .Ако `fd` е единственият файлов дескриптор, който сочи към тази дескрипция (виж `open(2)` ), ресурсите, асоциирани с нея, се освобождават.

При успешно затвяране на файла `close()` връща стойност `0` , а при грешка връща стойност `-1` и номерът на грешката се задава в `errno` .

## Задачи

Да се напише програма на C, която реализира командата:

1. `cat` (*без параметри*)
2. `tee ФАЙЛ` (подаваме `ФАЙЛ` като аргумент на програмата)
3. `cat >> ФАЙЛ` (подаваме `ФАЙЛ` като аргумент на програмата)
4. `head -cN ФАЙЛ` , където `N` е броят символи, които да се изведат от началото на файла (подаваме `N` и `ФАЙЛ` като аргументи на програмата)
5. `tail -c+N ФАЙЛ` , където `N` е броят символи от началото на файла, които да се пропуснат, преди да се изведе останалата част от файла (подаваме `N` и `ФАЙЛ` като аргументи на програмата)
6. `cat ФАЙЛ...` (идеята е да се разшири имплементацията на първата задача, така че да могат да ѝ се подават неограничен брой имена на файлове като аргументи)

## Допълнителни разяснения по решенията на задачите

Може да използвате командата `make` , за да компилирате всички решения наведнъж.Ако искате да компилирате решението на конкретна задача, използвайте `make $EXERCISE_NAME` , където `$EXERCISE_NAME` е името на файла с решението на задачата без разширението му (например `1-cat` ).Едно примерно извикване на командата ще изглежда по следния начин: `make 1-cat` .

Ако искате да изтриете всички компилирани решения наведнъж, може да използвате командата `make clean` .

