# Навигация във файлове
(записки към четвъртото упражнение)

Употреба на системното извикване `lseek(2)` .

## `lseek(2)` 

    #include <unistd.h>

    off_t lseek(int fd, off_t offset, int whence);

Системното извикване `lseek()` променя текущата позиция на четене или писане в отворения файл (т.е.пореден номер на байт в него, започващ от `0` ), асоцииран с файловия дескриптор `fd` .То ѝ задава стойност `offset` , съобразявайки се с директивата `whence` по следния начин:

* ако стойността на `whence` е `SEEK_SET` , на позицията се задава абсолютна стойност `offset` (т.е.спрямо началото на файла); 
* ако стойността на `whence` е `SEEK_CUR` , към текущата позиция се прибавя `offset` ; 
* ако стойността на `whence` е `SEEK_END` , на позицията се задава абсолютна стойност размерът на файла (т.е.номера на байта след последния) плюс `offset` .

Ако стойността на `whence` е `SEEK_CUR` или `SEEK_END` , е възможно е стойността на `offset` да е отрицателна, при което съответно от текущата позиция или от размера на файла се изважда съответният брой байтове (и на позицията се задава тази стойност).

`lseek()` позволява задаване на позиция след края на файла.Това не променя директно размера му, но при последващо записване на данни на такава позиция във файла се създава т.нар.*дупка* между предишния край на файла и началото на новозаписаните данни, която представлява поредица от нулеви байтове ( `\0` ).

При успешно преместване на текущата позиция `lseek()` връща абсолютната стойност на новата позиция.При грешка `lseek()` връща стойност `-1` и номерът на грешката се задава в `errno` .

## Задачи

1.Напишете програма на C, която приема като аргументи число `N` , `ДУМА` и `ФАЙЛ` и замества съдържанието на файла на позиция `N` (започваща от нула) с подадената като аргумент `ДУМА` .Ако `N` е отрицателно, позицията се отчита спрямо края на файла (т.е.позицията след последния байт от файла е `-1` ).

2.Напишете програма на C, която приема като аргументи числа `M` и `N` , както и `СИМВОЛ` и `ФАЙЛ` , и замества съдържанието на файла между позиции `M` и `N` включително с подадения като аргумент `СИМВОЛ` . `M` и `N` може да са отрицателни.

3.Напишете програма на C, която приема име на вече съществуващ файл като аргумент, отваря го за писане в края му (използвайки флага `O_APPEND` ), премества текущата позиция в началото на файла и накрая записва някакви данни в него.Къде (на коя позиция) ще се появят тези данни във файла?  Защо?

4.Напишете програма на C, която работи като `cp ФАЙЛ1 ФАЙЛ2` , но копира дупките в първия файл по ефикасен начин (т.е.без да записва чрез `write()` нулевите байтове в тях).

5.Напишете програма на C със следния команден ред: `atomic_append [-l] ФАЙЛ N` (аргументът `-l` не е задължителен, затова е ограден в квадратни скоби).

   Тази програма трябва да отваря подадения като аргумент `ФАЙЛ` (създавайки го, ако не съществува) и да записва `N` на брой байта в него, използвайки отделни извиквания на `write()` за всеки един от тях.По подразбиране програмата трябва да отваря файла, използвайки флага `O_APPEND` , но ако бъде подаден аргументът `-l` , вместо да използва `O_APPEND` , програмата ще изпълнява `lseek(fileno, 0, SEEK_END)` преди всеки `write()` .

   За да тествате програмата, изпълнете я два пъти едновременно с едни и същи аргументи, без да подавате `-l` като аргумент:

       $ atomic_append f1 1000000 & atomic_append f1 1000000

   Сега повторете експеримента, записвайки в друг файл, но този път подайте `-l` като аргумент:

       $ atomic_append -l f2 1000000 & atomic_append -l f2 1000000

   Проверете размерите на двата файла `f1` и `f2` и обяснете разликите.

