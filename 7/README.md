# Създаване и управление на процеси

Употреба на системните извиквания `fork(2)` , `wait(2)` , `waitpid(2)` , `exit(3)` .

## `fork(2)` 

    #include <unistd.h>

    pid_t fork(void);

Системното извикване `fork()` създава нов процес чрез създаване на копие на процеса, който го е извикал.Новият процес се нарича процес-дете, а старият - процес-родител.
При `fork()` се копира всичко от паметта, свързана с процеса: изображението му (т.е.програмата, която се изпълнява), стекът с извикванията, хийпът на процеса, както и файловите дескриптори и текущия контекст на процеса.Родителят и детето са напълно независими един от друг и сегментите им в паметта са напълно отделни.
При успех `fork()` връща номера (*PID*) на новосъздадения процес в процеса-родител.В процеса-дете `fork()` връща 0.При провал на операцията върнатата стойност е `-1` .

## `wait(2)` 

    #include <sys/wait.h>

    pid_t wait(int* status);

Системното извикване `wait()` изчаква приключването на който и да е процес от децата на текущия процес, т.е.тя блокира изпълнението на програмата, докато той не завърши.В аргумента `status` се подава указател към целочислена променлива, в която се запазва върнатият изходен код от процеса-дете (който всъщност е аргументът, подаден на `exit` в процеса-дете, или върнатата стойност в неговата `main` функция), както и друга информация, свързана с приключването на процеса.
При успех `wait()` връща PID-а на приключилия процес, а при провал връща `-1` .
За да се провери дали процесът е приключил успешно, може да се използва макросът `WEXITSTATUS` , който приема като аргумент стойността на променливата `status` и връща кода на завършване на процеса.Друг полезен макрос е `WIFEXITED` , който приема като аргумент стойността на `status` и връща дали процесът е приключил по нормален начин (т.е.чрез извикване на `exit(3)` ).

## `waitpid(2)` 

    #include <sys/wait.h>

    pid_t waitpid(pid_t pid, int* status, int options);

Системното извикване `waitpid()` изчаква приключването процеса с посочения в аргумента `pid` процесен идентификатор.Той трябва да е дете на текущия процес.Аргументът `status` се ползва по същия начин, както в `wait` , а в `options` се подават специални флагове (по подразбиране се подава стойност `0` ).
При успех `waitpid()` връща PID-а на приключилия процес, а при провал връща `-1` .

## `exit(3)` 

    #include <stdlib.h>

    void exit(int status);

Функцията `exit()` се използва за приключване на изпълнението на процес с подадения в аргумента `status` изходен код (който се използва от `wait` и `waitpid` , вж.горе).Вътрешно тя извиква системния примитив `_exit(2)` .

## Задачи

1. Напишете програма на C, която поражда нов процес, който директно приключва без грешки, и извежда номера му и кода му на завършване.

2. Напишете програма на C, която получава като параметри на командния ред име на команда и списък с аргументи, изпълнява командата и извежда кода ѝ на завършване.

3. Напишете програма на C, която изпълнява всяка една от командите, подадени като аргументи на командния ред.

4.Напишете програма на C, която получава като параметри на командния ред две имена на команди ( `CMD1` и `CMD2` ) и реализира конструкцията `CMD1 && CMD2` .

5.Напишете програма на C, която получава като параметри на командния ред две имена на команди ( `CMD1` и `CMD2` ) и реализира конструкцията `CMD1 || CMD2` .

6. Имплементирайте програмата от задача 4. по такъв начин, че да работи с неограничен брой команди.

7. Имплементирайте програмата от задача 5. по такъв начин, че да работи с неограничен брой команди.

